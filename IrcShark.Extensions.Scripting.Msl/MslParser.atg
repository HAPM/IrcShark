using System.Text;
using System.Collections.Generic;

COMPILER MslParser


/* Coco/R compiler generation file. See Help > Coco/R Help for more information. */

    // Put C# methods/variables here - they will be copied to the generated Parser.cs
  
/*--------------------------------------------------------------------------*/
CHARACTERS
    letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
    digit = "0123456789".
    cr  = '\r'.
    lf  = '\n'.
    tab = '\t'.
    space = ' '.
    identifierprefix = '$'.
    varprefix ='%'.
    special = "(){}[],:=!$/\"%".
    inwordspecial = "():,".
    inwordnonspecial = special - inwordspecial.
	other = ANY - letter - digit - cr - lf - space - tab - special.
  

TOKENS
    multiop = ( "===" | "==" | "!=" |">" | "<" | "//" | "\\\\" | "&" 
             | "isin" | "isincs" | "iswm" | "iswmcs"
             ) CONTEXT (space).
    singleop = ( "isnum" | "isletter" | "isalnum" | "isalpha" | "islower" | "isupper" ) CONTEXT (space).
    number = digit {digit}.
    word = ( letter | other ) { digit | letter | inwordnonspecial }.
    strconcat = identifierprefix '+' CONTEXT (space).
    idcall = identifierprefix { letter | digit | other | tab | inwordnonspecial }.
    varname = varprefix { letter | digit | other | inwordnonspecial }.
    sp = space { space }.
    EOL = [cr] lf.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM ";" TO lf

PRODUCTIONS
/*------------------------------------------------------------------------*/
MslParser (. CodeMemberMethod alias; 
           .)
=   {   AliasDecl<out alias>    (. script.Members.Add(alias); .)
    | sp
    | EOL
    }
    EOF
.

AliasDecl<out CodeMemberMethod method> (. method = SetupAlias();
                                          List<CodeStatement> stmts = new List<CodeStatement>();
                                          string name;
                                        .)
=	"alias" sp
    [   "-l" sp                         (. method.Attributes = MemberAttributes.Private | MemberAttributes.Final; .)
    ] 
    AliasName<out name>                 (. method.Name = "Alias" + name; .)
    sp 
    (   CommandBlock<method.Statements> 
    |   CommandLine<method.Statements> )
. 

AliasName<out string name> (. StringBuilder result = new StringBuilder(); .)
=	(	number             (. result.Append(t.val); .)
	|	word               (. result.Append(t.val); .)
	)
	{	number             (. result.Append(t.val); .)
	|	word               (. result.Append(t.val); .)
	}                      (. name = result.ToString(); .)
.

Command<CodeStatementCollection stmts>   (. CodeStatement temp = null; .)
=   (   ExpressionLine<out temp>
    |   IfClause<out temp>
    )                                    (. stmts.Add(temp); .)
.

IfClause<out CodeStatement result>                 (. CodeConditionStatement ifStmt = SetupIfStatement(); 
                                                      CodeExpression boolExp;
                                                    .)
=   "if" sp "(" BooleanExpression<out boolExp> ")" (. ifStmt.Condition = boolExp; .)
    sp
    (   CommandBlock<ifStmt.TrueStatements>
    |   CommandLine<ifStmt.TrueStatements>
    )
    [ sp ]                                         (. result = ifStmt; .)
.

CommandLine<CodeStatementCollection result>
=   Command<result>
    { "|" sp Command<result>
    }
    [ sp ]
.

CommandBlock<CodeStatementCollection result> 
=   "{" [ sp [ CommandLine<result>
    ] ] { EOL [ sp ] [ 
        CommandLine<result>
    ] } "}" [ sp ] [ Command<result> ]
.

BooleanExpression<out CodeExpression boolExp> (. string op = null;
                                                 CodeExpression leftExpression = null;
                                                 CodeExpression rightExpression = null;
                                                 boolExp = null;
                                               .)
=   "(" [sp] BooleanExpression<out boolExp> [sp] ")"
|   BooleanExpressionParameter<out leftExpression>          (. boolExp = BooleanEvaluation(leftExpression); .)
    [   {   multiop                                         (. op = t.val; .)
            BooleanExpressionParameter<out rightExpression> (. boolExp = BooleanEvaluation(leftExpression, t.val, rightExpression); 
                                                               leftExpression = boolExp;
                                                             .)
        }
    |   singleop                                            (. boolExp = BooleanEvaluation(leftExpression, t.val); .)
    ]
.

Expression<out CodeExpression result>      (. result = null; .)
=   StaticExpression<out result>
|   IdentifierCall<out result>
|   varname                                (. string temp = "v_" + t.val.Substring(1);
                                              result = new CodeVariableReferenceExpression(temp); 
                                            .)
.

StaticExpression<out CodeExpression result> (. StringBuilder data = new StringBuilder(); .)
=   (   word                                     (. data.Append(t.val); .)
    |   number                                   (. data.Append(t.val); .)
    |   "."                                      (. data.Append(t.val); .)
    )
    {   word                                     (. data.Append(t.val); .)
    |   sp                                       (. data.Append(t.val); .)
    |   number                                   (. data.Append(t.val); .)
    |   "."                                      (. data.Append(t.val); .)
    }                                            (. result = new CodePrimitiveExpression(data.ToString()); .)
.

IdentifierCall<out CodeExpression result>       (. string idname;
                                                   string prop = null;
                                                   List<CodeExpression> parameters = new List<CodeExpression>();
                                                   CodeExpression temp;
                                                 .)
=   idcall                                      (. idname = t.val; .)
    [ "(" [
        ExpressionParameter<out temp>           (. parameters.Add(temp); .)
        { "," [ sp ] [
            ExpressionParameter<out temp>       (. parameters.Add(temp); .)
        ] } ] ")" [ "." word                    (. prop = t.val; .)
    ] ]                                         (. result = CallIdentifier(idname, parameters.ToArray(), prop); .)
.

ExpressionParameter<out CodeExpression result> (. string currentSpace;
                                                  CodeExpression temp; .)
=   Expression<out result>
    {   Expression<out temp>                   (. result = new CodeBinaryOperatorExpression(result, CodeBinaryOperatorType.Add, temp); .)
    |   sp                                     (. currentSpace = t.val; .) 
        (   strconcat sp
        |                                      (. result = new CodeBinaryOperatorExpression(result, CodeBinaryOperatorType.Add, new CodePrimitiveExpression(currentSpace)); .)
        )                 
    } 
.

BooleanExpressionParameter<out CodeExpression result>   (. string currentSpace;
                                                           CodeExpression temp; .)
=   Expression<out result>
    {   Expression<out temp>                            (. result = new CodeBinaryOperatorExpression(result, CodeBinaryOperatorType.Add, temp); .)
    |   ","                                             (. result = new CodeBinaryOperatorExpression(result, CodeBinaryOperatorType.Add, new CodePrimitiveExpression(t.val)); .)
    |   sp                                              (. currentSpace = t.val; .) 
        (   strconcat sp
        |                                               (. result = new CodeBinaryOperatorExpression(result, CodeBinaryOperatorType.Add, new CodePrimitiveExpression(currentSpace)); .)
        )                 
    } 
.

ExpressionLine<out CodeStatement result>       (. string currentSpace;
                                                  CodeExpression line;
                                                  CodeExpression temp; .)
=   Expression<out line>
    {   Expression<out temp>                   (. line = new CodeBinaryOperatorExpression(line, CodeBinaryOperatorType.Add, temp); .)
    |   sp                                     (. currentSpace = t.val; .)
        (   strconcat sp
        |                                      (. line = new CodeBinaryOperatorExpression(line, CodeBinaryOperatorType.Add, new CodePrimitiveExpression(currentSpace)); .)
        )
    }                                          (. result = CallAlias(line); .)
.

END MslParser.

